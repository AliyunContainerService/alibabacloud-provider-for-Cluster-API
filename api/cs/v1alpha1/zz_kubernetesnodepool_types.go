// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DataDisksInitParameters struct {

	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyID *string `json:"autoSnapshotPolicyId,omitempty" tf:"auto_snapshot_policy_id,omitempty"`

	// The type of the data disks. Valid values:cloud, cloud_efficiency, cloud_ssd and cloud_essd.
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// Specifies whether to encrypt data disks. Valid values: true and false. Default to false.
	Encrypted *string `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// The kms key id used to encrypt the data disk. It takes effect when encrypted is true.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The name of data disk N. Valid values of N: 1 to 16. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Worker node data disk performance level, when category values cloud_essd, the optional values are PL0, PL1, PL2 or PL3, but the specific performance level is related to the disk capacity. For more information, see Enhanced SSDs. Default is PL1.
	PerformanceLevel *string `json:"performanceLevel,omitempty" tf:"performance_level,omitempty"`

	// The size of a data disk, Its valid value range [40~32768] in GB. Default to 40.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`
}

type DataDisksObservation struct {

	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyID *string `json:"autoSnapshotPolicyId,omitempty" tf:"auto_snapshot_policy_id,omitempty"`

	// The type of the data disks. Valid values:cloud, cloud_efficiency, cloud_ssd and cloud_essd.
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// Specifies whether to encrypt data disks. Valid values: true and false. Default to false.
	Encrypted *string `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// The kms key id used to encrypt the data disk. It takes effect when encrypted is true.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The name of data disk N. Valid values of N: 1 to 16. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Worker node data disk performance level, when category values cloud_essd, the optional values are PL0, PL1, PL2 or PL3, but the specific performance level is related to the disk capacity. For more information, see Enhanced SSDs. Default is PL1.
	PerformanceLevel *string `json:"performanceLevel,omitempty" tf:"performance_level,omitempty"`

	// The size of a data disk, Its valid value range [40~32768] in GB. Default to 40.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`
}

type DataDisksParameters struct {

	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	// +kubebuilder:validation:Optional
	AutoSnapshotPolicyID *string `json:"autoSnapshotPolicyId,omitempty" tf:"auto_snapshot_policy_id,omitempty"`

	// The type of the data disks. Valid values:cloud, cloud_efficiency, cloud_ssd and cloud_essd.
	// +kubebuilder:validation:Optional
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	// +kubebuilder:validation:Optional
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// Specifies whether to encrypt data disks. Valid values: true and false. Default to false.
	// +kubebuilder:validation:Optional
	Encrypted *string `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// The kms key id used to encrypt the data disk. It takes effect when encrypted is true.
	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The name of data disk N. Valid values of N: 1 to 16. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Worker node data disk performance level, when category values cloud_essd, the optional values are PL0, PL1, PL2 or PL3, but the specific performance level is related to the disk capacity. For more information, see Enhanced SSDs. Default is PL1.
	// +kubebuilder:validation:Optional
	PerformanceLevel *string `json:"performanceLevel,omitempty" tf:"performance_level,omitempty"`

	// The size of a data disk, Its valid value range [40~32768] in GB. Default to 40.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`
}

type KubeletConfigurationInitParameters struct {

	// Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is none or static.
	CPUManagerPolicy *string `json:"cpuManagerPolicy,omitempty" tf:"cpu_manager_policy,omitempty"`

	// Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding event_record_qps. It is only used when event_record_qps is greater than 0. Valid value is [0-100].
	EventBurst *string `json:"eventBurst,omitempty" tf:"event_burst,omitempty"`

	// Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is [0-50].
	EventRecordQPS *string `json:"eventRecordQps,omitempty" tf:"event_record_qps,omitempty"`

	// Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +mapType=granular
	EvictionHard map[string]*string `json:"evictionHard,omitempty" tf:"eviction_hard,omitempty"`

	// Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +mapType=granular
	EvictionSoft map[string]*string `json:"evictionSoft,omitempty" tf:"eviction_soft,omitempty"`

	// Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: {"memory.available" = "30s"}.
	// +mapType=granular
	EvictionSoftGracePeriod map[string]*string `json:"evictionSoftGracePeriod,omitempty" tf:"eviction_soft_grace_period,omitempty"`

	// Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is [0-100].
	KubeAPIBurst *string `json:"kubeApiBurst,omitempty" tf:"kube_api_burst,omitempty"`

	// Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is [0-50].
	KubeAPIQPS *string `json:"kubeApiQps,omitempty" tf:"kube_api_qps,omitempty"`

	// Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See compute resources for more details.
	// +mapType=granular
	KubeReserved map[string]*string `json:"kubeReserved,omitempty" tf:"kube_reserved,omitempty"`

	// Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. Only used if registry_pull_qps is greater than 0. Valid value is [0-100].
	RegistryBurst *string `json:"registryBurst,omitempty" tf:"registry_burst,omitempty"`

	// Same as registryPullQPS. The limit of registry pulls per second. Setting it to 0 means no limit. Valid value is [0-50].
	RegistryPullQPS *string `json:"registryPullQps,omitempty" tf:"registry_pull_qps,omitempty"`

	// Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is true or false.
	SerializeImagePulls *string `json:"serializeImagePulls,omitempty" tf:"serialize_image_pulls,omitempty"`

	// Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See compute resources for more details.
	// +mapType=granular
	SystemReserved map[string]*string `json:"systemReserved,omitempty" tf:"system_reserved,omitempty"`
}

type KubeletConfigurationObservation struct {

	// Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is none or static.
	CPUManagerPolicy *string `json:"cpuManagerPolicy,omitempty" tf:"cpu_manager_policy,omitempty"`

	// Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding event_record_qps. It is only used when event_record_qps is greater than 0. Valid value is [0-100].
	EventBurst *string `json:"eventBurst,omitempty" tf:"event_burst,omitempty"`

	// Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is [0-50].
	EventRecordQPS *string `json:"eventRecordQps,omitempty" tf:"event_record_qps,omitempty"`

	// Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +mapType=granular
	EvictionHard map[string]*string `json:"evictionHard,omitempty" tf:"eviction_hard,omitempty"`

	// Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +mapType=granular
	EvictionSoft map[string]*string `json:"evictionSoft,omitempty" tf:"eviction_soft,omitempty"`

	// Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: {"memory.available" = "30s"}.
	// +mapType=granular
	EvictionSoftGracePeriod map[string]*string `json:"evictionSoftGracePeriod,omitempty" tf:"eviction_soft_grace_period,omitempty"`

	// Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is [0-100].
	KubeAPIBurst *string `json:"kubeApiBurst,omitempty" tf:"kube_api_burst,omitempty"`

	// Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is [0-50].
	KubeAPIQPS *string `json:"kubeApiQps,omitempty" tf:"kube_api_qps,omitempty"`

	// Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See compute resources for more details.
	// +mapType=granular
	KubeReserved map[string]*string `json:"kubeReserved,omitempty" tf:"kube_reserved,omitempty"`

	// Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. Only used if registry_pull_qps is greater than 0. Valid value is [0-100].
	RegistryBurst *string `json:"registryBurst,omitempty" tf:"registry_burst,omitempty"`

	// Same as registryPullQPS. The limit of registry pulls per second. Setting it to 0 means no limit. Valid value is [0-50].
	RegistryPullQPS *string `json:"registryPullQps,omitempty" tf:"registry_pull_qps,omitempty"`

	// Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is true or false.
	SerializeImagePulls *string `json:"serializeImagePulls,omitempty" tf:"serialize_image_pulls,omitempty"`

	// Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See compute resources for more details.
	// +mapType=granular
	SystemReserved map[string]*string `json:"systemReserved,omitempty" tf:"system_reserved,omitempty"`
}

type KubeletConfigurationParameters struct {

	// Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is none or static.
	// +kubebuilder:validation:Optional
	CPUManagerPolicy *string `json:"cpuManagerPolicy,omitempty" tf:"cpu_manager_policy,omitempty"`

	// Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding event_record_qps. It is only used when event_record_qps is greater than 0. Valid value is [0-100].
	// +kubebuilder:validation:Optional
	EventBurst *string `json:"eventBurst,omitempty" tf:"event_burst,omitempty"`

	// Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is [0-50].
	// +kubebuilder:validation:Optional
	EventRecordQPS *string `json:"eventRecordQps,omitempty" tf:"event_record_qps,omitempty"`

	// Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	EvictionHard map[string]*string `json:"evictionHard,omitempty" tf:"eviction_hard,omitempty"`

	// Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	EvictionSoft map[string]*string `json:"evictionSoft,omitempty" tf:"eviction_soft,omitempty"`

	// Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: {"memory.available" = "30s"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	EvictionSoftGracePeriod map[string]*string `json:"evictionSoftGracePeriod,omitempty" tf:"eviction_soft_grace_period,omitempty"`

	// Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is [0-100].
	// +kubebuilder:validation:Optional
	KubeAPIBurst *string `json:"kubeApiBurst,omitempty" tf:"kube_api_burst,omitempty"`

	// Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is [0-50].
	// +kubebuilder:validation:Optional
	KubeAPIQPS *string `json:"kubeApiQps,omitempty" tf:"kube_api_qps,omitempty"`

	// Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See compute resources for more details.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	KubeReserved map[string]*string `json:"kubeReserved,omitempty" tf:"kube_reserved,omitempty"`

	// Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. Only used if registry_pull_qps is greater than 0. Valid value is [0-100].
	// +kubebuilder:validation:Optional
	RegistryBurst *string `json:"registryBurst,omitempty" tf:"registry_burst,omitempty"`

	// Same as registryPullQPS. The limit of registry pulls per second. Setting it to 0 means no limit. Valid value is [0-50].
	// +kubebuilder:validation:Optional
	RegistryPullQPS *string `json:"registryPullQps,omitempty" tf:"registry_pull_qps,omitempty"`

	// Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is true or false.
	// +kubebuilder:validation:Optional
	SerializeImagePulls *string `json:"serializeImagePulls,omitempty" tf:"serialize_image_pulls,omitempty"`

	// Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See compute resources for more details.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	SystemReserved map[string]*string `json:"systemReserved,omitempty" tf:"system_reserved,omitempty"`
}

type KubernetesNodePoolInitParameters struct {

	// Enable Node payment auto-renew, default is false.
	AutoRenew *bool `json:"autoRenew,omitempty" tf:"auto_renew,omitempty"`

	// Node payment auto-renew period, one of 1, 2, 3,6, 12.
	AutoRenewPeriod *float64 `json:"autoRenewPeriod,omitempty" tf:"auto_renew_period,omitempty"`

	// Kubelet cpu policy. For Kubernetes 1.12.6 and later, its valid value is either static or none. Default to none and modification is not supported.
	CPUPolicy *string `json:"cpuPolicy,omitempty" tf:"cpu_policy,omitempty"`

	// Whether enable worker node to support cis security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See CIS Reinforcement.
	CisEnabled *bool `json:"cisEnabled,omitempty" tf:"cis_enabled,omitempty"`

	// The id of kubernetes cluster.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// The data disk configurations of worker nodes, such as the disk type and disk size. See data_disks below.
	DataDisks []DataDisksInitParameters `json:"dataDisks,omitempty" tf:"data_disks,omitempty"`

	// The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
	DeploymentSetID *string `json:"deploymentSetId,omitempty" tf:"deployment_set_id,omitempty"`

	// The desired size of nodes of the node pool. From version 1.158.0, desired_size is not required.
	DesiredSize *float64 `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// After you select this check box, if data disks have been attached to the specified ECS instances and the file system of the last data disk is uninitialized, the system automatically formats the last data disk to ext4 and mounts the data disk to /var/lib/docker and /var/lib/kubelet. The original data on the disk will be cleared. Make sure that you back up data in advance. If no data disk is mounted on the ECS instance, no new data disk will be purchased. Default is false.
	FormatDisk *bool `json:"formatDisk,omitempty" tf:"format_disk,omitempty"`

	// Custom Image support. Must based on CentOS7 or AliyunLinux2.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The image type, instead of platform. This field cannot be modified. One of AliyunLinux, AliyunLinux3, AliyunLinux3Arm64, AliyunLinuxUEFI, CentOS, Windows,WindowsCore,AliyunLinux Qboot,ContainerOS. If you select Windows or WindowsCore, the passord is required.
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// Install the cloud monitoring plug-in on the node, and you can view the monitoring information of the instance through the cloud monitoring console. Default is true.
	InstallCloudMonitor *bool `json:"installCloudMonitor,omitempty" tf:"install_cloud_monitor,omitempty"`

	// Node payment type. Valid values: PostPaid, PrePaid, default is PostPaid. If value is PrePaid, the arguments period, period_unit, auto_renew and auto_renew_period are required.
	InstanceChargeType *string `json:"instanceChargeType,omitempty" tf:"instance_charge_type,omitempty"`

	// The instance type of worker node.
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// The instance list. Add existing nodes under the same cluster VPC to the node pool.
	Instances []*string `json:"instances,omitempty" tf:"instances,omitempty"`

	// The billing method for network usage. Valid values PayByBandwidth and PayByTraffic. Conflict with eip_internet_charge_type, EIP and public network IP can only choose one.
	InternetChargeType *string `json:"internetChargeType,omitempty" tf:"internet_charge_type,omitempty"`

	// The maximum outbound bandwidth for the public network. Unit: Mbit/s. Valid values: 0 to 100.
	InternetMaxBandwidthOut *float64 `json:"internetMaxBandwidthOut,omitempty" tf:"internet_max_bandwidth_out,omitempty"`

	// An KMS encrypts password used to a cs kubernetes. You have to specify one of password key_name kms_encrypted_password fields.
	KMSEncryptedPassword *string `json:"kmsEncryptedPassword,omitempty" tf:"kms_encrypted_password,omitempty"`

	// An KMS encryption context used to decrypt kms_encrypted_password before creating or updating a cs kubernetes with kms_encrypted_password. See Encryption Context. It is valid when kms_encrypted_password is set.
	// +mapType=granular
	KMSEncryptionContext map[string]*string `json:"kmsEncryptionContext,omitempty" tf:"kms_encryption_context,omitempty"`

	// Add an existing instance to the node pool, whether to keep the original instance name. It is recommended to set to true.
	KeepInstanceName *bool `json:"keepInstanceName,omitempty" tf:"keep_instance_name,omitempty"`

	// The keypair of ssh login cluster node, you have to create it first. You have to specify one of password key_name kms_encrypted_password fields. Only key_name is supported in the management node pool.
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// Kubelet configuration parameters for worker nodes. See kubelet_configuration below. More information in Kubelet Configuration.
	KubeletConfiguration []KubeletConfigurationInitParameters `json:"kubeletConfiguration,omitempty" tf:"kubelet_configuration,omitempty"`

	// A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in Labels. See labels below.
	Labels []LabelsInitParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// Managed node pool configuration. When using a managed node pool, the node key must use key_name. See management below.
	Management []ManagementInitParameters `json:"management,omitempty" tf:"management,omitempty"`

	// The name of node pool.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Each node name consists of a prefix, its private network IP, and a suffix, the input format is customized,<prefix>,ip,<suffix>. For example "customized,aliyun.com-,ip,-test", if the node private network IP address is 192.168.59.176, the prefix is aliyun.com-,and the suffix is -test, the node name will be aliyun.com-192.168.59.176-test.
	NodeNameMode *string `json:"nodeNameMode,omitempty" tf:"node_name_mode,omitempty"`

	// Node payment period. Its valid value is one of {1, 2, 3, 6, 12, 24, 36, 48, 60}.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// Node payment period unit, valid value: Month. Default is Month.
	PeriodUnit *string `json:"periodUnit,omitempty" tf:"period_unit,omitempty"`

	// PolarDB id list, You can choose which PolarDB whitelist to add instances to.
	PolardbIds []*string `json:"polardbIds,omitempty" tf:"polardb_ids,omitempty"`

	// RDS instance list, You can choose which RDS instances whitelist to add instances to.
	RDSInstances []*string `json:"rdsInstances,omitempty" tf:"rds_instances,omitempty"`

	// The ID of the resource group,by default these cloud resources are automatically assigned to the default resource group.
	ResourceGroupID *string `json:"resourceGroupId,omitempty" tf:"resource_group_id,omitempty"`

	// Rolling policy is used to specify the strategy when the node pool is rolling update. This field works when nodepool updating. See rolling_policy below.
	RollingPolicy []RollingPolicyInitParameters `json:"rollingPolicy,omitempty" tf:"rolling_policy,omitempty"`

	// The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see Comparison of Docker, containerd, and Sandboxed-Container.
	RuntimeName *string `json:"runtimeName,omitempty" tf:"runtime_name,omitempty"`

	// The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
	RuntimeVersion *string `json:"runtimeVersion,omitempty" tf:"runtime_version,omitempty"`

	// Auto scaling node pool configuration. See scaling_config below. With auto-scaling is enabled, the nodes in the node pool will be labeled with k8s.aliyun.com=true to prevent system pods such as coredns, metrics-servers from being scheduled to elastic nodes, and to prevent node shrinkage from causing business abnormalities.
	ScalingConfig []ScalingConfigInitParameters `json:"scalingConfig,omitempty" tf:"scaling_config,omitempty"`

	// The scaling mode. Valid values: release, recycle, default is release. Standard mode(release): Create and release ECS instances based on requests.Swift mode(recycle): Create, stop, and restart ECS instances based on needs. New ECS instances are only created when no stopped ECS instance is avalible. This mode further accelerates the scaling process. Apart from ECS instances that use local storage, when an ECS instance is stopped, you are only chatged for storage space.
	ScalingPolicy *string `json:"scalingPolicy,omitempty" tf:"scaling_policy,omitempty"`

	// Multiple security groups can be configured for a node pool. If both security_group_ids and security_group_id are configured, security_group_ids takes effect. This field cannot be modified.
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// Whether enable worker node to support soc security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See SOC Reinforcement.
	// -> NOTE: It is forbidden to set both cis_enabled and soc_enabled to trueat the same time.
	SocEnabled *bool `json:"socEnabled,omitempty" tf:"soc_enabled,omitempty"`

	// The maximum hourly price of the instance. This parameter takes effect only when spot_strategy is set to SpotWithPriceLimit. You could enable multiple spot instances by setting this field repeatedly. See spot_price_limit below.
	SpotPriceLimit []SpotPriceLimitInitParameters `json:"spotPriceLimit,omitempty" tf:"spot_price_limit,omitempty"`

	// The preemption policy for the pay-as-you-go instance. This parameter takes effect only when instance_charge_type is set to PostPaid. Valid value SpotWithPriceLimit,SpotAsPriceGo and NoSpot, default is NoSpot.
	SpotStrategy *string `json:"spotStrategy,omitempty" tf:"spot_strategy,omitempty"`

	// The system disk category of worker node. Its valid value are cloud_ssd, cloud_efficiency and cloud_essd. Default to cloud_efficiency.
	SystemDiskCategory *string `json:"systemDiskCategory,omitempty" tf:"system_disk_category,omitempty"`

	// The encryption Algorithm for Encrypting System Disk. It takes effect when system_disk_encrypted is true. Valid values aes-256 and sm4-128.
	SystemDiskEncryptAlgorithm *string `json:"systemDiskEncryptAlgorithm,omitempty" tf:"system_disk_encrypt_algorithm,omitempty"`

	// Whether to enable system disk encryption.
	SystemDiskEncrypted *bool `json:"systemDiskEncrypted,omitempty" tf:"system_disk_encrypted,omitempty"`

	// The kms key id used to encrypt the system disk. It takes effect when system_disk_encrypted is true.
	SystemDiskKMSKey *string `json:"systemDiskKmsKey,omitempty" tf:"system_disk_kms_key,omitempty"`

	// The performance of system disk, only valid for ESSD disk. You have to specify one of PL0 PL1 PL2 PL3 fields.
	SystemDiskPerformanceLevel *string `json:"systemDiskPerformanceLevel,omitempty" tf:"system_disk_performance_level,omitempty"`

	// The system disk category of worker node. Its valid value range [40~500] in GB. Default to 120.
	SystemDiskSize *float64 `json:"systemDiskSize,omitempty" tf:"system_disk_size,omitempty"`

	// The system disk snapshot policy id.
	SystemDiskSnapshotPolicyID *string `json:"systemDiskSnapshotPolicyId,omitempty" tf:"system_disk_snapshot_policy_id,omitempty"`

	// A Map of tags to assign to the resource. It will be applied for ECS instances finally. Detailed below.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// A List of Kubernetes taints to assign to the nodes. Detailed below. More information in Taints and Toleration. See taints below.
	Taints []TaintsInitParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// Set the newly added node as unschedulable. If you want to open the scheduling option, you can open it in the node list of the console. If you are using an auto-scaling node pool, the setting will not take effect. Default is false.
	Unschedulable *bool `json:"unschedulable,omitempty" tf:"unschedulable,omitempty"`

	// Windows instances support batch and PowerShell scripts. If your script file is larger than 1 KB, we recommend that you upload the script to Object Storage Service (OSS) and pull it through the internal endpoint of your OSS bucket.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The vswitches used by node pool workers.
	VswitchIds []*string `json:"vswitchIds,omitempty" tf:"vswitch_ids,omitempty"`
}

type KubernetesNodePoolObservation struct {

	// Enable Node payment auto-renew, default is false.
	AutoRenew *bool `json:"autoRenew,omitempty" tf:"auto_renew,omitempty"`

	// Node payment auto-renew period, one of 1, 2, 3,6, 12.
	AutoRenewPeriod *float64 `json:"autoRenewPeriod,omitempty" tf:"auto_renew_period,omitempty"`

	// Kubelet cpu policy. For Kubernetes 1.12.6 and later, its valid value is either static or none. Default to none and modification is not supported.
	CPUPolicy *string `json:"cpuPolicy,omitempty" tf:"cpu_policy,omitempty"`

	// Whether enable worker node to support cis security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See CIS Reinforcement.
	CisEnabled *bool `json:"cisEnabled,omitempty" tf:"cis_enabled,omitempty"`

	// The id of kubernetes cluster.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// The data disk configurations of worker nodes, such as the disk type and disk size. See data_disks below.
	DataDisks []DataDisksObservation `json:"dataDisks,omitempty" tf:"data_disks,omitempty"`

	// The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
	DeploymentSetID *string `json:"deploymentSetId,omitempty" tf:"deployment_set_id,omitempty"`

	// The desired size of nodes of the node pool. From version 1.158.0, desired_size is not required.
	DesiredSize *float64 `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// After you select this check box, if data disks have been attached to the specified ECS instances and the file system of the last data disk is uninitialized, the system automatically formats the last data disk to ext4 and mounts the data disk to /var/lib/docker and /var/lib/kubelet. The original data on the disk will be cleared. Make sure that you back up data in advance. If no data disk is mounted on the ECS instance, no new data disk will be purchased. Default is false.
	FormatDisk *bool `json:"formatDisk,omitempty" tf:"format_disk,omitempty"`

	// The ID of the node pool, format cluster_id:nodepool_id.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Custom Image support. Must based on CentOS7 or AliyunLinux2.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The image type, instead of platform. This field cannot be modified. One of AliyunLinux, AliyunLinux3, AliyunLinux3Arm64, AliyunLinuxUEFI, CentOS, Windows,WindowsCore,AliyunLinux Qboot,ContainerOS. If you select Windows or WindowsCore, the passord is required.
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// Install the cloud monitoring plug-in on the node, and you can view the monitoring information of the instance through the cloud monitoring console. Default is true.
	InstallCloudMonitor *bool `json:"installCloudMonitor,omitempty" tf:"install_cloud_monitor,omitempty"`

	// Node payment type. Valid values: PostPaid, PrePaid, default is PostPaid. If value is PrePaid, the arguments period, period_unit, auto_renew and auto_renew_period are required.
	InstanceChargeType *string `json:"instanceChargeType,omitempty" tf:"instance_charge_type,omitempty"`

	// The instance type of worker node.
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// The instance list. Add existing nodes under the same cluster VPC to the node pool.
	Instances []*string `json:"instances,omitempty" tf:"instances,omitempty"`

	// The billing method for network usage. Valid values PayByBandwidth and PayByTraffic. Conflict with eip_internet_charge_type, EIP and public network IP can only choose one.
	InternetChargeType *string `json:"internetChargeType,omitempty" tf:"internet_charge_type,omitempty"`

	// The maximum outbound bandwidth for the public network. Unit: Mbit/s. Valid values: 0 to 100.
	InternetMaxBandwidthOut *float64 `json:"internetMaxBandwidthOut,omitempty" tf:"internet_max_bandwidth_out,omitempty"`

	// An KMS encrypts password used to a cs kubernetes. You have to specify one of password key_name kms_encrypted_password fields.
	KMSEncryptedPassword *string `json:"kmsEncryptedPassword,omitempty" tf:"kms_encrypted_password,omitempty"`

	// An KMS encryption context used to decrypt kms_encrypted_password before creating or updating a cs kubernetes with kms_encrypted_password. See Encryption Context. It is valid when kms_encrypted_password is set.
	// +mapType=granular
	KMSEncryptionContext map[string]*string `json:"kmsEncryptionContext,omitempty" tf:"kms_encryption_context,omitempty"`

	// Add an existing instance to the node pool, whether to keep the original instance name. It is recommended to set to true.
	KeepInstanceName *bool `json:"keepInstanceName,omitempty" tf:"keep_instance_name,omitempty"`

	// The keypair of ssh login cluster node, you have to create it first. You have to specify one of password key_name kms_encrypted_password fields. Only key_name is supported in the management node pool.
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// Kubelet configuration parameters for worker nodes. See kubelet_configuration below. More information in Kubelet Configuration.
	KubeletConfiguration []KubeletConfigurationObservation `json:"kubeletConfiguration,omitempty" tf:"kubelet_configuration,omitempty"`

	// A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in Labels. See labels below.
	Labels []LabelsObservation `json:"labels,omitempty" tf:"labels,omitempty"`

	// Managed node pool configuration. When using a managed node pool, the node key must use key_name. See management below.
	Management []ManagementObservation `json:"management,omitempty" tf:"management,omitempty"`

	// The name of node pool.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Each node name consists of a prefix, its private network IP, and a suffix, the input format is customized,<prefix>,ip,<suffix>. For example "customized,aliyun.com-,ip,-test", if the node private network IP address is 192.168.59.176, the prefix is aliyun.com-,and the suffix is -test, the node name will be aliyun.com-192.168.59.176-test.
	NodeNameMode *string `json:"nodeNameMode,omitempty" tf:"node_name_mode,omitempty"`

	// Node payment period. Its valid value is one of {1, 2, 3, 6, 12, 24, 36, 48, 60}.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// Node payment period unit, valid value: Month. Default is Month.
	PeriodUnit *string `json:"periodUnit,omitempty" tf:"period_unit,omitempty"`

	// PolarDB id list, You can choose which PolarDB whitelist to add instances to.
	PolardbIds []*string `json:"polardbIds,omitempty" tf:"polardb_ids,omitempty"`

	// RDS instance list, You can choose which RDS instances whitelist to add instances to.
	RDSInstances []*string `json:"rdsInstances,omitempty" tf:"rds_instances,omitempty"`

	// The ID of the resource group,by default these cloud resources are automatically assigned to the default resource group.
	ResourceGroupID *string `json:"resourceGroupId,omitempty" tf:"resource_group_id,omitempty"`

	// Rolling policy is used to specify the strategy when the node pool is rolling update. This field works when nodepool updating. See rolling_policy below.
	RollingPolicy []RollingPolicyObservation `json:"rollingPolicy,omitempty" tf:"rolling_policy,omitempty"`

	// The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see Comparison of Docker, containerd, and Sandboxed-Container.
	RuntimeName *string `json:"runtimeName,omitempty" tf:"runtime_name,omitempty"`

	// The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
	RuntimeVersion *string `json:"runtimeVersion,omitempty" tf:"runtime_version,omitempty"`

	// Auto scaling node pool configuration. See scaling_config below. With auto-scaling is enabled, the nodes in the node pool will be labeled with k8s.aliyun.com=true to prevent system pods such as coredns, metrics-servers from being scheduled to elastic nodes, and to prevent node shrinkage from causing business abnormalities.
	ScalingConfig []ScalingConfigObservation `json:"scalingConfig,omitempty" tf:"scaling_config,omitempty"`

	// The scaling group id.
	ScalingGroupID *string `json:"scalingGroupId,omitempty" tf:"scaling_group_id,omitempty"`

	// The scaling mode. Valid values: release, recycle, default is release. Standard mode(release): Create and release ECS instances based on requests.Swift mode(recycle): Create, stop, and restart ECS instances based on needs. New ECS instances are only created when no stopped ECS instance is avalible. This mode further accelerates the scaling process. Apart from ECS instances that use local storage, when an ECS instance is stopped, you are only chatged for storage space.
	ScalingPolicy *string `json:"scalingPolicy,omitempty" tf:"scaling_policy,omitempty"`

	// Multiple security groups can be configured for a node pool. If both security_group_ids and security_group_id are configured, security_group_ids takes effect. This field cannot be modified.
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// Whether enable worker node to support soc security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See SOC Reinforcement.
	// -> NOTE: It is forbidden to set both cis_enabled and soc_enabled to trueat the same time.
	SocEnabled *bool `json:"socEnabled,omitempty" tf:"soc_enabled,omitempty"`

	// The maximum hourly price of the instance. This parameter takes effect only when spot_strategy is set to SpotWithPriceLimit. You could enable multiple spot instances by setting this field repeatedly. See spot_price_limit below.
	SpotPriceLimit []SpotPriceLimitObservation `json:"spotPriceLimit,omitempty" tf:"spot_price_limit,omitempty"`

	// The preemption policy for the pay-as-you-go instance. This parameter takes effect only when instance_charge_type is set to PostPaid. Valid value SpotWithPriceLimit,SpotAsPriceGo and NoSpot, default is NoSpot.
	SpotStrategy *string `json:"spotStrategy,omitempty" tf:"spot_strategy,omitempty"`

	// The system disk category of worker node. Its valid value are cloud_ssd, cloud_efficiency and cloud_essd. Default to cloud_efficiency.
	SystemDiskCategory *string `json:"systemDiskCategory,omitempty" tf:"system_disk_category,omitempty"`

	// The encryption Algorithm for Encrypting System Disk. It takes effect when system_disk_encrypted is true. Valid values aes-256 and sm4-128.
	SystemDiskEncryptAlgorithm *string `json:"systemDiskEncryptAlgorithm,omitempty" tf:"system_disk_encrypt_algorithm,omitempty"`

	// Whether to enable system disk encryption.
	SystemDiskEncrypted *bool `json:"systemDiskEncrypted,omitempty" tf:"system_disk_encrypted,omitempty"`

	// The kms key id used to encrypt the system disk. It takes effect when system_disk_encrypted is true.
	SystemDiskKMSKey *string `json:"systemDiskKmsKey,omitempty" tf:"system_disk_kms_key,omitempty"`

	// The performance of system disk, only valid for ESSD disk. You have to specify one of PL0 PL1 PL2 PL3 fields.
	SystemDiskPerformanceLevel *string `json:"systemDiskPerformanceLevel,omitempty" tf:"system_disk_performance_level,omitempty"`

	// The system disk category of worker node. Its valid value range [40~500] in GB. Default to 120.
	SystemDiskSize *float64 `json:"systemDiskSize,omitempty" tf:"system_disk_size,omitempty"`

	// The system disk snapshot policy id.
	SystemDiskSnapshotPolicyID *string `json:"systemDiskSnapshotPolicyId,omitempty" tf:"system_disk_snapshot_policy_id,omitempty"`

	// A Map of tags to assign to the resource. It will be applied for ECS instances finally. Detailed below.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// A List of Kubernetes taints to assign to the nodes. Detailed below. More information in Taints and Toleration. See taints below.
	Taints []TaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	// Set the newly added node as unschedulable. If you want to open the scheduling option, you can open it in the node list of the console. If you are using an auto-scaling node pool, the setting will not take effect. Default is false.
	Unschedulable *bool `json:"unschedulable,omitempty" tf:"unschedulable,omitempty"`

	// Windows instances support batch and PowerShell scripts. If your script file is larger than 1 KB, we recommend that you upload the script to Object Storage Service (OSS) and pull it through the internal endpoint of your OSS bucket.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The VPC of the nodes in the node pool.
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`

	// The vswitches used by node pool workers.
	VswitchIds []*string `json:"vswitchIds,omitempty" tf:"vswitch_ids,omitempty"`
}

type KubernetesNodePoolParameters struct {

	// Enable Node payment auto-renew, default is false.
	// +kubebuilder:validation:Optional
	AutoRenew *bool `json:"autoRenew,omitempty" tf:"auto_renew,omitempty"`

	// Node payment auto-renew period, one of 1, 2, 3,6, 12.
	// +kubebuilder:validation:Optional
	AutoRenewPeriod *float64 `json:"autoRenewPeriod,omitempty" tf:"auto_renew_period,omitempty"`

	// Kubelet cpu policy. For Kubernetes 1.12.6 and later, its valid value is either static or none. Default to none and modification is not supported.
	// +kubebuilder:validation:Optional
	CPUPolicy *string `json:"cpuPolicy,omitempty" tf:"cpu_policy,omitempty"`

	// Whether enable worker node to support cis security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See CIS Reinforcement.
	// +kubebuilder:validation:Optional
	CisEnabled *bool `json:"cisEnabled,omitempty" tf:"cis_enabled,omitempty"`

	// The id of kubernetes cluster.
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// The data disk configurations of worker nodes, such as the disk type and disk size. See data_disks below.
	// +kubebuilder:validation:Optional
	DataDisks []DataDisksParameters `json:"dataDisks,omitempty" tf:"data_disks,omitempty"`

	// The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
	// +kubebuilder:validation:Optional
	DeploymentSetID *string `json:"deploymentSetId,omitempty" tf:"deployment_set_id,omitempty"`

	// The desired size of nodes of the node pool. From version 1.158.0, desired_size is not required.
	// +kubebuilder:validation:Optional
	DesiredSize *float64 `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// After you select this check box, if data disks have been attached to the specified ECS instances and the file system of the last data disk is uninitialized, the system automatically formats the last data disk to ext4 and mounts the data disk to /var/lib/docker and /var/lib/kubelet. The original data on the disk will be cleared. Make sure that you back up data in advance. If no data disk is mounted on the ECS instance, no new data disk will be purchased. Default is false.
	// +kubebuilder:validation:Optional
	FormatDisk *bool `json:"formatDisk,omitempty" tf:"format_disk,omitempty"`

	// Custom Image support. Must based on CentOS7 or AliyunLinux2.
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The image type, instead of platform. This field cannot be modified. One of AliyunLinux, AliyunLinux3, AliyunLinux3Arm64, AliyunLinuxUEFI, CentOS, Windows,WindowsCore,AliyunLinux Qboot,ContainerOS. If you select Windows or WindowsCore, the passord is required.
	// +kubebuilder:validation:Optional
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// Install the cloud monitoring plug-in on the node, and you can view the monitoring information of the instance through the cloud monitoring console. Default is true.
	// +kubebuilder:validation:Optional
	InstallCloudMonitor *bool `json:"installCloudMonitor,omitempty" tf:"install_cloud_monitor,omitempty"`

	// Node payment type. Valid values: PostPaid, PrePaid, default is PostPaid. If value is PrePaid, the arguments period, period_unit, auto_renew and auto_renew_period are required.
	// +kubebuilder:validation:Optional
	InstanceChargeType *string `json:"instanceChargeType,omitempty" tf:"instance_charge_type,omitempty"`

	// The instance type of worker node.
	// +kubebuilder:validation:Optional
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// The instance list. Add existing nodes under the same cluster VPC to the node pool.
	// +kubebuilder:validation:Optional
	Instances []*string `json:"instances,omitempty" tf:"instances,omitempty"`

	// The billing method for network usage. Valid values PayByBandwidth and PayByTraffic. Conflict with eip_internet_charge_type, EIP and public network IP can only choose one.
	// +kubebuilder:validation:Optional
	InternetChargeType *string `json:"internetChargeType,omitempty" tf:"internet_charge_type,omitempty"`

	// The maximum outbound bandwidth for the public network. Unit: Mbit/s. Valid values: 0 to 100.
	// +kubebuilder:validation:Optional
	InternetMaxBandwidthOut *float64 `json:"internetMaxBandwidthOut,omitempty" tf:"internet_max_bandwidth_out,omitempty"`

	// An KMS encrypts password used to a cs kubernetes. You have to specify one of password key_name kms_encrypted_password fields.
	// +kubebuilder:validation:Optional
	KMSEncryptedPassword *string `json:"kmsEncryptedPassword,omitempty" tf:"kms_encrypted_password,omitempty"`

	// An KMS encryption context used to decrypt kms_encrypted_password before creating or updating a cs kubernetes with kms_encrypted_password. See Encryption Context. It is valid when kms_encrypted_password is set.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	KMSEncryptionContext map[string]*string `json:"kmsEncryptionContext,omitempty" tf:"kms_encryption_context,omitempty"`

	// Add an existing instance to the node pool, whether to keep the original instance name. It is recommended to set to true.
	// +kubebuilder:validation:Optional
	KeepInstanceName *bool `json:"keepInstanceName,omitempty" tf:"keep_instance_name,omitempty"`

	// The keypair of ssh login cluster node, you have to create it first. You have to specify one of password key_name kms_encrypted_password fields. Only key_name is supported in the management node pool.
	// +kubebuilder:validation:Optional
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// Kubelet configuration parameters for worker nodes. See kubelet_configuration below. More information in Kubelet Configuration.
	// +kubebuilder:validation:Optional
	KubeletConfiguration []KubeletConfigurationParameters `json:"kubeletConfiguration,omitempty" tf:"kubelet_configuration,omitempty"`

	// A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in Labels. See labels below.
	// +kubebuilder:validation:Optional
	Labels []LabelsParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// Managed node pool configuration. When using a managed node pool, the node key must use key_name. See management below.
	// +kubebuilder:validation:Optional
	Management []ManagementParameters `json:"management,omitempty" tf:"management,omitempty"`

	// The name of node pool.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Each node name consists of a prefix, its private network IP, and a suffix, the input format is customized,<prefix>,ip,<suffix>. For example "customized,aliyun.com-,ip,-test", if the node private network IP address is 192.168.59.176, the prefix is aliyun.com-,and the suffix is -test, the node name will be aliyun.com-192.168.59.176-test.
	// +kubebuilder:validation:Optional
	NodeNameMode *string `json:"nodeNameMode,omitempty" tf:"node_name_mode,omitempty"`

	// The password of ssh login cluster node. You have to specify one of password key_name kms_encrypted_password fields.
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// Node payment period. Its valid value is one of {1, 2, 3, 6, 12, 24, 36, 48, 60}.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// Node payment period unit, valid value: Month. Default is Month.
	// +kubebuilder:validation:Optional
	PeriodUnit *string `json:"periodUnit,omitempty" tf:"period_unit,omitempty"`

	// PolarDB id list, You can choose which PolarDB whitelist to add instances to.
	// +kubebuilder:validation:Optional
	PolardbIds []*string `json:"polardbIds,omitempty" tf:"polardb_ids,omitempty"`

	// RDS instance list, You can choose which RDS instances whitelist to add instances to.
	// +kubebuilder:validation:Optional
	RDSInstances []*string `json:"rdsInstances,omitempty" tf:"rds_instances,omitempty"`

	// The ID of the resource group,by default these cloud resources are automatically assigned to the default resource group.
	// +kubebuilder:validation:Optional
	ResourceGroupID *string `json:"resourceGroupId,omitempty" tf:"resource_group_id,omitempty"`

	// Rolling policy is used to specify the strategy when the node pool is rolling update. This field works when nodepool updating. See rolling_policy below.
	// +kubebuilder:validation:Optional
	RollingPolicy []RollingPolicyParameters `json:"rollingPolicy,omitempty" tf:"rolling_policy,omitempty"`

	// The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see Comparison of Docker, containerd, and Sandboxed-Container.
	// +kubebuilder:validation:Optional
	RuntimeName *string `json:"runtimeName,omitempty" tf:"runtime_name,omitempty"`

	// The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
	// +kubebuilder:validation:Optional
	RuntimeVersion *string `json:"runtimeVersion,omitempty" tf:"runtime_version,omitempty"`

	// Auto scaling node pool configuration. See scaling_config below. With auto-scaling is enabled, the nodes in the node pool will be labeled with k8s.aliyun.com=true to prevent system pods such as coredns, metrics-servers from being scheduled to elastic nodes, and to prevent node shrinkage from causing business abnormalities.
	// +kubebuilder:validation:Optional
	ScalingConfig []ScalingConfigParameters `json:"scalingConfig,omitempty" tf:"scaling_config,omitempty"`

	// The scaling mode. Valid values: release, recycle, default is release. Standard mode(release): Create and release ECS instances based on requests.Swift mode(recycle): Create, stop, and restart ECS instances based on needs. New ECS instances are only created when no stopped ECS instance is avalible. This mode further accelerates the scaling process. Apart from ECS instances that use local storage, when an ECS instance is stopped, you are only chatged for storage space.
	// +kubebuilder:validation:Optional
	ScalingPolicy *string `json:"scalingPolicy,omitempty" tf:"scaling_policy,omitempty"`

	// Multiple security groups can be configured for a node pool. If both security_group_ids and security_group_id are configured, security_group_ids takes effect. This field cannot be modified.
	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// Whether enable worker node to support soc security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See SOC Reinforcement.
	// -> NOTE: It is forbidden to set both cis_enabled and soc_enabled to trueat the same time.
	// +kubebuilder:validation:Optional
	SocEnabled *bool `json:"socEnabled,omitempty" tf:"soc_enabled,omitempty"`

	// The maximum hourly price of the instance. This parameter takes effect only when spot_strategy is set to SpotWithPriceLimit. You could enable multiple spot instances by setting this field repeatedly. See spot_price_limit below.
	// +kubebuilder:validation:Optional
	SpotPriceLimit []SpotPriceLimitParameters `json:"spotPriceLimit,omitempty" tf:"spot_price_limit,omitempty"`

	// The preemption policy for the pay-as-you-go instance. This parameter takes effect only when instance_charge_type is set to PostPaid. Valid value SpotWithPriceLimit,SpotAsPriceGo and NoSpot, default is NoSpot.
	// +kubebuilder:validation:Optional
	SpotStrategy *string `json:"spotStrategy,omitempty" tf:"spot_strategy,omitempty"`

	// The system disk category of worker node. Its valid value are cloud_ssd, cloud_efficiency and cloud_essd. Default to cloud_efficiency.
	// +kubebuilder:validation:Optional
	SystemDiskCategory *string `json:"systemDiskCategory,omitempty" tf:"system_disk_category,omitempty"`

	// The encryption Algorithm for Encrypting System Disk. It takes effect when system_disk_encrypted is true. Valid values aes-256 and sm4-128.
	// +kubebuilder:validation:Optional
	SystemDiskEncryptAlgorithm *string `json:"systemDiskEncryptAlgorithm,omitempty" tf:"system_disk_encrypt_algorithm,omitempty"`

	// Whether to enable system disk encryption.
	// +kubebuilder:validation:Optional
	SystemDiskEncrypted *bool `json:"systemDiskEncrypted,omitempty" tf:"system_disk_encrypted,omitempty"`

	// The kms key id used to encrypt the system disk. It takes effect when system_disk_encrypted is true.
	// +kubebuilder:validation:Optional
	SystemDiskKMSKey *string `json:"systemDiskKmsKey,omitempty" tf:"system_disk_kms_key,omitempty"`

	// The performance of system disk, only valid for ESSD disk. You have to specify one of PL0 PL1 PL2 PL3 fields.
	// +kubebuilder:validation:Optional
	SystemDiskPerformanceLevel *string `json:"systemDiskPerformanceLevel,omitempty" tf:"system_disk_performance_level,omitempty"`

	// The system disk category of worker node. Its valid value range [40~500] in GB. Default to 120.
	// +kubebuilder:validation:Optional
	SystemDiskSize *float64 `json:"systemDiskSize,omitempty" tf:"system_disk_size,omitempty"`

	// The system disk snapshot policy id.
	// +kubebuilder:validation:Optional
	SystemDiskSnapshotPolicyID *string `json:"systemDiskSnapshotPolicyId,omitempty" tf:"system_disk_snapshot_policy_id,omitempty"`

	// A Map of tags to assign to the resource. It will be applied for ECS instances finally. Detailed below.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// A List of Kubernetes taints to assign to the nodes. Detailed below. More information in Taints and Toleration. See taints below.
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// Set the newly added node as unschedulable. If you want to open the scheduling option, you can open it in the node list of the console. If you are using an auto-scaling node pool, the setting will not take effect. Default is false.
	// +kubebuilder:validation:Optional
	Unschedulable *bool `json:"unschedulable,omitempty" tf:"unschedulable,omitempty"`

	// Windows instances support batch and PowerShell scripts. If your script file is larger than 1 KB, we recommend that you upload the script to Object Storage Service (OSS) and pull it through the internal endpoint of your OSS bucket.
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The vswitches used by node pool workers.
	// +kubebuilder:validation:Optional
	VswitchIds []*string `json:"vswitchIds,omitempty" tf:"vswitch_ids,omitempty"`
}

type LabelsInitParameters struct {

	// The label key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsObservation struct {

	// The label key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsParameters struct {

	// The label key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// The label value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ManagementInitParameters struct {

	// Whether automatic repair, Default to false.
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Whether auto upgrade, Default to false.
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// Max number of unavailable nodes. Default to 1.
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// Number of additional nodes. You have to specify one of surge, surge_percentage.
	Surge *float64 `json:"surge,omitempty" tf:"surge,omitempty"`

	// Proportion of additional nodes. You have to specify one of surge, surge_percentage.
	SurgePercentage *float64 `json:"surgePercentage,omitempty" tf:"surge_percentage,omitempty"`
}

type ManagementObservation struct {

	// Whether automatic repair, Default to false.
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Whether auto upgrade, Default to false.
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// Max number of unavailable nodes. Default to 1.
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// Number of additional nodes. You have to specify one of surge, surge_percentage.
	Surge *float64 `json:"surge,omitempty" tf:"surge,omitempty"`

	// Proportion of additional nodes. You have to specify one of surge, surge_percentage.
	SurgePercentage *float64 `json:"surgePercentage,omitempty" tf:"surge_percentage,omitempty"`
}

type ManagementParameters struct {

	// Whether automatic repair, Default to false.
	// +kubebuilder:validation:Optional
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Whether auto upgrade, Default to false.
	// +kubebuilder:validation:Optional
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// Max number of unavailable nodes. Default to 1.
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable" tf:"max_unavailable,omitempty"`

	// Number of additional nodes. You have to specify one of surge, surge_percentage.
	// +kubebuilder:validation:Optional
	Surge *float64 `json:"surge,omitempty" tf:"surge,omitempty"`

	// Proportion of additional nodes. You have to specify one of surge, surge_percentage.
	// +kubebuilder:validation:Optional
	SurgePercentage *float64 `json:"surgePercentage,omitempty" tf:"surge_percentage,omitempty"`
}

type RollingPolicyInitParameters struct {

	// Maximum parallel number nodes during rolling upgrade. The value of this field should be greater than 0, and if it's set to a number less than or equal to 0, the default setting will be used.
	MaxParallelism *float64 `json:"maxParallelism,omitempty" tf:"max_parallelism,omitempty"`
}

type RollingPolicyObservation struct {

	// Maximum parallel number nodes during rolling upgrade. The value of this field should be greater than 0, and if it's set to a number less than or equal to 0, the default setting will be used.
	MaxParallelism *float64 `json:"maxParallelism,omitempty" tf:"max_parallelism,omitempty"`
}

type RollingPolicyParameters struct {

	// Maximum parallel number nodes during rolling upgrade. The value of this field should be greater than 0, and if it's set to a number less than or equal to 0, the default setting will be used.
	// +kubebuilder:validation:Optional
	MaxParallelism *float64 `json:"maxParallelism,omitempty" tf:"max_parallelism,omitempty"`
}

type ScalingConfigInitParameters struct {

	// Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to 5.
	EIPBandwidth *float64 `json:"eipBandwidth,omitempty" tf:"eip_bandwidth,omitempty"`

	// EIP billing type. PayByBandwidth: Charged at fixed bandwidth. PayByTraffic: Billed as used traffic. Default: PayByBandwidth. Conflict with internet_charge_type, EIP and public network IP can only choose one.
	EIPInternetChargeType *string `json:"eipInternetChargeType,omitempty" tf:"eip_internet_charge_type,omitempty"`

	// Whether to bind EIP for an instance. Default: false.
	IsBondEIP *bool `json:"isBondEip,omitempty" tf:"is_bond_eip,omitempty"`

	// Max number of instances in a auto scaling group, its valid value range [0~1000]. max_size has to be greater than min_size.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Min number of instances in a auto scaling group, its valid value range [0~1000].
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// Instance classification, not required. Vaild value: cpu, gpu, gpushare and spot. Default: cpu. The actual instance type is determined by instance_types.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ScalingConfigObservation struct {

	// Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to 5.
	EIPBandwidth *float64 `json:"eipBandwidth,omitempty" tf:"eip_bandwidth,omitempty"`

	// EIP billing type. PayByBandwidth: Charged at fixed bandwidth. PayByTraffic: Billed as used traffic. Default: PayByBandwidth. Conflict with internet_charge_type, EIP and public network IP can only choose one.
	EIPInternetChargeType *string `json:"eipInternetChargeType,omitempty" tf:"eip_internet_charge_type,omitempty"`

	// Whether to bind EIP for an instance. Default: false.
	IsBondEIP *bool `json:"isBondEip,omitempty" tf:"is_bond_eip,omitempty"`

	// Max number of instances in a auto scaling group, its valid value range [0~1000]. max_size has to be greater than min_size.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Min number of instances in a auto scaling group, its valid value range [0~1000].
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// Instance classification, not required. Vaild value: cpu, gpu, gpushare and spot. Default: cpu. The actual instance type is determined by instance_types.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ScalingConfigParameters struct {

	// Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to 5.
	// +kubebuilder:validation:Optional
	EIPBandwidth *float64 `json:"eipBandwidth,omitempty" tf:"eip_bandwidth,omitempty"`

	// EIP billing type. PayByBandwidth: Charged at fixed bandwidth. PayByTraffic: Billed as used traffic. Default: PayByBandwidth. Conflict with internet_charge_type, EIP and public network IP can only choose one.
	// +kubebuilder:validation:Optional
	EIPInternetChargeType *string `json:"eipInternetChargeType,omitempty" tf:"eip_internet_charge_type,omitempty"`

	// Whether to bind EIP for an instance. Default: false.
	// +kubebuilder:validation:Optional
	IsBondEIP *bool `json:"isBondEip,omitempty" tf:"is_bond_eip,omitempty"`

	// Max number of instances in a auto scaling group, its valid value range [0~1000]. max_size has to be greater than min_size.
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize" tf:"max_size,omitempty"`

	// Min number of instances in a auto scaling group, its valid value range [0~1000].
	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize" tf:"min_size,omitempty"`

	// Instance classification, not required. Vaild value: cpu, gpu, gpushare and spot. Default: cpu. The actual instance type is determined by instance_types.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SpotPriceLimitInitParameters struct {

	// Spot instance type.
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The maximum hourly price of the spot instance. A maximum of three decimal places are allowed.
	PriceLimit *string `json:"priceLimit,omitempty" tf:"price_limit,omitempty"`
}

type SpotPriceLimitObservation struct {

	// Spot instance type.
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The maximum hourly price of the spot instance. A maximum of three decimal places are allowed.
	PriceLimit *string `json:"priceLimit,omitempty" tf:"price_limit,omitempty"`
}

type SpotPriceLimitParameters struct {

	// Spot instance type.
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The maximum hourly price of the spot instance. A maximum of three decimal places are allowed.
	// +kubebuilder:validation:Optional
	PriceLimit *string `json:"priceLimit,omitempty" tf:"price_limit,omitempty"`
}

type TaintsInitParameters struct {

	// The scheduling policy.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The key of a taint.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The value of a taint.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsObservation struct {

	// The scheduling policy.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The key of a taint.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The value of a taint.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsParameters struct {

	// The scheduling policy.
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The key of a taint.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// The value of a taint.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

// KubernetesNodePoolSpec defines the desired state of KubernetesNodePool
type KubernetesNodePoolSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KubernetesNodePoolParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider KubernetesNodePoolInitParameters `json:"initProvider,omitempty"`
}

// KubernetesNodePoolStatus defines the observed state of KubernetesNodePool.
type KubernetesNodePoolStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KubernetesNodePoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// KubernetesNodePool is the Schema for the KubernetesNodePools API. Provides a Alicloud resource to manage container kubernetes node pool.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alibabacloud}
type KubernetesNodePool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterId) || (has(self.initProvider) && has(self.initProvider.clusterId))",message="spec.forProvider.clusterId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.instanceTypes) || (has(self.initProvider) && has(self.initProvider.instanceTypes))",message="spec.forProvider.instanceTypes is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.vswitchIds) || (has(self.initProvider) && has(self.initProvider.vswitchIds))",message="spec.forProvider.vswitchIds is a required parameter"
	Spec   KubernetesNodePoolSpec   `json:"spec"`
	Status KubernetesNodePoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KubernetesNodePoolList contains a list of KubernetesNodePools
type KubernetesNodePoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KubernetesNodePool `json:"items"`
}

// Repository type metadata.
var (
	KubernetesNodePool_Kind             = "KubernetesNodePool"
	KubernetesNodePool_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: KubernetesNodePool_Kind}.String()
	KubernetesNodePool_KindAPIVersion   = KubernetesNodePool_Kind + "." + CRDGroupVersion.String()
	KubernetesNodePool_GroupVersionKind = CRDGroupVersion.WithKind(KubernetesNodePool_Kind)
)

func init() {
	SchemeBuilder.Register(&KubernetesNodePool{}, &KubernetesNodePoolList{})
}
